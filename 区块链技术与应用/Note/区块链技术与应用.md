# 区块链技术与应用

[TOC]

## BTC-密码学原理

### cryptographic hash function

- collision resistance
- hiding 单向不可逆

上述两种性质可以实现digital commitment或者digital equivalent of a sealed envelope (sealed envelop：预测可能会对结果产生影响，因此可以将$H(x)$作为预测值公布，之后验证$x$，实际操作的时候用的是$H(x||nonce)$来保证均匀分布)

BTC使用的hash (SHA-256, Secure Hash Algorithm) 还有一个性质：

- puzzle friendly (difficult to solve, but easy to verify)

  挖矿就是一直试不同的$nonce$使得$H(block~header)\le target$即为合法值，这个词表示必须通过遍历来试——工作量证明proof of work

### 账户管理

开户的过程：创建一个公钥和私钥 `(public key, private key)`

加密和解密用的都是接收方的

公钥：账号；私钥：密码

BTC交易时用私钥来做签名，其他人用公钥解密验证

假设产生公私钥的过程使用的是好的随机元 a good source of randomness

## BTC-数据结构

### Hash pointers

保存结构体首地址和其hash值

如果有环的话，就产生问题

### Blockchain

Block chain is a linked list using hash pointers.

第一个区块叫genesis block，最后一个区块是most recent block，由hash pointer连接起来，注意hash值是对前一个区块整体取hash得到的——tamper-evident log

### Merkle Tree

和Binary Tree的区别是用hash pointer代替binary tree的指针

内部节点都是hash pointer，leaf是data block（交易数据transaction），对根节点取hash就是root hash

BTC有两种节点：全节点（保存block header和block body）和轻节点（只保存block header），Merkle Tree提供了Merkle proof

proof of membership (inclusion) 复杂度 $\Theta(\log n)$

proof of non-membership (non-membership)：将leaf按照hash值排序，然后对需要被验证的transaction取hash看位于哪两个leaf之间，只要能证明这两个leaf能够推到root正确即可。验证复杂度 $\Theta(\log n)$，需要排序的称为Sorted Merkle Tree但是BTC不需要验证non-membership

## BTC-协议

数字货币存在double spending attack

区块链：每个交易要包含输入和输出，输入包含钱的来源——铸币交易coinbase transaction（使用hash指针）以及**转账人的公钥**，输出包含收款人公钥的hash，还需要转账人的签名

每个节点都需要知道转账人的公钥，因为交易签名使用的是转账人的私钥，大家验证需要使用其公钥验证

铸币交易的输出包含获得人的公钥，后续交易的输入公钥需要和最初的coinbase交易的公钥对得上

实际上BTC上每个区块链上都也很多交易组成Merkle Tree

每个区块分成Block header和Block body

| Block header                                                 | Block body       |
| ------------------------------------------------------------ | ---------------- |
| version                                                      | transaction list |
| hash of previous block header <br />(only caculate block header) |                  |
| Merkle root hash                                             |                  |
| nBits（256位target的压缩编码 4bytes）                        |                  |
| nonce                                                        |                  |

BTC每个节点可分为full node (fully validating node) 和 light node (只保存block header)，主要是后者

账本内容要取得分布式的共识distributed consensus，共同维护distributed hash table

有人提出FLP impossibility result，即在一个异步且时延没有上限的网络中，只要有一个人是faulty，整个网络就无法达成共识；另外有人提出CAP Theorem (Consistency, Availability, Partition tolerance)，即这三个性质最多得到两个

BTC的共识协议：

若采用投票，需要确定membership（如hyperledger fabric联盟链，只有某些大公司能参与，投票可以），BTC中恶意者不断产生公私钥就一直获得投票权sybil attack。

在BTC中，$H(block~header)\le target$中有一个4bytes的$nounce$，求出符合该式的$nounce$即可获得记账权

当hash of previous block header不是指向longest valid chain的最后的时候，这个区块就新开了一个分支（分叉攻击forking attack），正常情况应该是接在最长合法链的后面。

但是还有一种情况，两个区块同时获得记账权，都接在longest valid chain的最后产生分叉，此时各个本地区块会根据网络延迟先接上两者之一。之后如果在两者其中之一继续先扩展下一个区块（看算力和运气）就变成了最长合法链，另外一个就变成了orphan block被丢弃掉

BTC设置block reward来让大家争夺记账权，因为这是铸币的唯一方式

## BTC-系统实现

BTC：transaction-base ledger

全节点在内存中维护UTXO (Unspent Transaction Output)，防止double spending

除了出块奖励之外，为了防止某人在打包区块链的时候只打包自己的交易记录，于是提供了transaction fee作为奖励

为了增大nounce的搜索空间，可以使用coinbase txn的前几个字节作为extra nounce，因为coinbase txn的内容是随意的但是修改它会导致Merkle Tree Root的hash值发生改变

尝试nounce成功是伯努利过程，接近于Possion分布，无记忆性（将来挖的时间和过去挖的时间没有关系），系统平均出块时间为10min

BTC的数量：
$$
210000*50+210000*25+\dots\\=210000*50*(1+\frac12+\frac14+\dots)=21000000
$$
挖矿求解过程没有意义，但是Bitcoin is secured by mining：当大部分算力掌握在诚实节点上的时候就是安全的（用算力投票）

记账权的获得有时候看运气，所以可能会落入恶意节点，此时

- 不能偷币（因为没有转账人的私钥签名，即使写到链上，它不是最长**合法**链所以诚实节点不会接上去，所以此恶意攻击者甚至拿不到出块奖励）
- 可能出现double spending——难度较大（forking attack，同时写入转账和回滚产生分支，交易平台看到写入转账的区块就认为交易成功，但是之后可能回滚分支成为最长合法链，如果本来转账分支之后就已经接着很多区块了，这种方法就比较困难，所以BTC的防范方法是six confirmation，需要1小时时间，故BTC的不可篡改性是概率上的保证；另一种方法是zero confirmation，直接选择最先被接受的节点，或者电商平台本来交易完到发货就有时间差可以用来检验合法性）
- 故意不包含合法交易，但是总有合法的区块会发布这些交易

- selfish mining——正常情况下挖到区块直接发布，但是也可以挖到多块区块连在一起然后forking attack一次性接上去。但是前提是恶意算力比较大的时候才比较容易成功篡改。但是这种方法也有好处，减少竞争，关键还是需要算力比较大，风险在于当别人比你早挖出来的时候要赶紧接上去

ETH：account-based ledger

系统显式地记录每个账户上的币

## BTC-网络

BTC工作在application layer，底层network layer是P2P Overlay Network，在这个网络里所有节点都是平等的，没有super node/master node，加入网络需要知道seed node种子节点

BTC网络的目标：简单，鲁棒而不是高效

BTC协议对区块大小的限制为1M

best effort，一个交易不一定让所有节点都收到，顺序也不一定一样，有些节点可能转发错误的交易

## BTC-挖矿难度的调整

$difficulty=\frac{difficulty\_1\_target}{target}$

分子是当难度为1（最低）的时候的目标阈值，是一个很大的数

出块时间太短导致：这个区块在网络上来不及广播，使得多分叉变成常态，一旦出现多分叉，善意的算力被分散，而恶意算力可以集中在一个分叉上使得其不断延伸成为最长合法链，使得51% attack的数字会变小

每2016个区块调整一下难度，大概是14天一次，$target=target\times \frac{actual~time}{expected~time}$

恶意节点无法执行调整nBits来降低难度因为别的区块验证会通不过

## BTC-挖矿

全节点：

- 一直在线

- 在本地硬盘中维护完整的区块链信息

- 在内存中维护UTXO集合，以便快速检验交易的正确性

- 监听比特币网络上的交易信息，验证每个交易的合法性

- 决定哪些交易会被打包到区块里

- 监听别的矿工挖出来的区块，验证其合法性

  - 交易合法（包括铸币的金额）

  - 是否符合难度要求，即block header取hash前面是否有足够多的0

    ，检查难度目标阈值是否正确

  - 是否接在最长合法链上

- 挖矿

轻节点：

- 不是一直在线
- 不用保存整个区块链，只要保存每个区块的块头
- 不用保存全部交易，只保存与自己相关的交易
- 无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性
- 无法检测网上发布的区块的正确性
- 可以验证挖矿的难度
- 只能检测哪个是最长链，不知道哪个是最长合法链

当监听到有人挖出一个区块之后，自己需要停止当前的挖矿然后重新打包一个区块然后开始挖矿——并不可惜，因为无记忆性 memoryless/progress free

目前挖矿常用ASIC（Application Specific Integrated Circuit）芯片，只适用于一种mining puzzle。有些币的mining puzzle会设置成和一个比较火的币一样，这种情况成为merge mining

矿池：pool manager矿主连着很多miner矿工，前者管理区块打包等工作，后者只负责解puzzle，如果挖出来就大家分成。分配收益的方法：每个矿工挖到一个share（almost valid block即接近valid block的一个区块）就发给矿主作为工作量证明。矿工不能自己发布出去赚钱，因为这个任务是由矿主分配的，这个区块的收款人地址是矿主，如果他改了这个地址那么就相当于单干，因为Merkle Tree Root值发生改变，矿主不会认为他是share

如果某个矿池得到51%算力，就可以使用分叉攻击、Boycott（封锁交易，所有和某人有关的交易全部回滚，不需要等待6个confirmation，这样别的矿工也会不打包和该人有关的交易，逼迫站队），但不能把别人的钱转走（因为没有别人的私钥）

## BTC-脚本 

基于栈的语言

```json
"result": {
    "txid":"921a...dd24",
    "hash":"921a...dd24",
    "version":1,
    "size":226,
    "locktime":0,
    "vin":[],
	"vout":[],
	"blockhash":"00000000002c510d...5c0b",
	"confirmations":23,
	"time":1530846727,
	"blocktime":1530846727
}
// locktime为0表示立刻生效

"vin": [{
    "txid":"",
    "vout":0,
    "scriptSig": {
        "asm":"",
        "hex":""
    }
}]
// 上面vout的值表示是txid交易的第几个输出

"vout": [{
    "value":0.1,
    "n":0,
    "scriptPubKey": {
        "asm":"DUP HASH160 628e... EQUALVERIFY CHECKSIG",
        "hex":"76a9...",
        "reqSigs":1,
        "type":"pubkeyhash",
        "addresses":["...."]
    }
}]
// 上面n表示为当前输出的第几个，asm输出脚本的内容，reqSigs表示需要的签名数量
```

某个区块A的输入来源于区块B的输出，那么将A的input script和B的output script（注意**不是**A的output script）拼接在一起，先执行前者，后执行后者，如果结果为true就表示合法

几种类型：

- P2PK (Pay to Public Key)
  - input script
    - PUSHDATA (Sig)
  - output script
    - PUSHDATA (PubKey)
    - CHECKSIG
- P2PKH (Pay to Public Key Hash) 最常用
  - input script
    - PUSHDATA (Sig) 压栈
    - PUSHDATA (PubKey) 压栈
  - output script
    - DUP 复制一份栈顶并压栈
    - HASH160 弹出栈顶pubkey取hash压入栈
    - PUSHDATA (PubKeyHash) 压入pubkeyhash
    - EQUALVERIFY 弹出栈顶两个hash值是否相等，防止某人以自己的公钥顶替
    - CHECKSIG 最后将sig和pubkey进行check正确就返回true

- P2SH (Pay to Script Hash)

  - input script

    - ...
    - PUSHDATA (Sig)
    - ...
    - PUSHDATA (serialized redeemScript)

  - output script

    - HASH160
    - PUSHDATA (redeemScriptHash)
    - EQUAL

  - 简单来说就是另外有一个redeem script，首先执行input和output，最后执行redeem的内容

  - 支持多重签名

    将input script中改成

    - false (Bitcoin的实现BUG，这里多压入一个没用的元素)
    - PUSHDATA (Sig_1)
    - ...
    - PUSHDATA (Sig_M)
    - PUSHDATA (serialized redeemScript)

    将redeemScript写成

    - M 表示总的签名数
    - PUSHDATA (pubkey_1)
    - ...
    - PUSHDATA (pubkey_N)
    - N
    - CHECKMULTISIG

- Proof of Burn
  - output script
    - RETURN [zero or more ops or text]
    - 这种形式的output被称为Provably Unspendable/Prunable Outputs
  - 脚本说明：return直接返回false，这个output无法被花出去，UTXO可以剪枝
  - 应用
    - AltCoin (Alternative Coin) 销毁Bitcoin获得小币
    - 花费非常少的BTC将某些内容取hash放到return后面，这样就能放到区块链上 （coinbase中也是随意记东西的，但是只有获得记账权的节点才能写东西）

## BTC-分叉

- state fork 状态分叉，意见分歧
  - 包括forking attack，也被称为deliberate fork
- protocol fork 协议分叉
  - 不同协议造成的分叉
  - 进一步分成hard fork和soft fork
  - hard fork
    - 扩展新的特性（如修改block size为4M）时如果不认可新的特性就会产生硬分叉
    - 旧节点在原来的链上不断延伸，新节点在新的链上延伸，产生永久性的分叉
    - 当前交易速度约为每秒7笔交易
    - 由此社区分裂成两帮人，一个币拆成了两个币，各自有自己的chain id 
  - soft fork
    - 临时的分叉（如修改block size为1M）
    - 旧节点会放弃旧链，在新链上延伸，但是此时新节点又不会认当前链为最长合法链而新开一个分叉，使得旧节点一直是白挖
    - 最终还是会变成一条链
    - 例子：给原来的某些域一些新的含义，比如给coinbase域增加含义extra nounce+UTXO的根hash

## BTC-课堂问答

- 如果收款人没有连接到BTC网络？

  没有关系

- OP_RETURN永远返回false为啥会写到区块链上？

  因为这个RETURN语句是写在output script，因此在验证这笔交易的时候并不执行

- 交易费给哪位？

  交易费等于总输入减总输出，剩下的直接给挖到的矿工即可

## BTC-匿名性

pseudonymity 匿名性不如纸币高于银行

不同账户之间可以建立关联、BTC和现实世界也可以形成关联

在network layer上实现匿名性：使用TOR

在application layer上实现匿名性：coin mixing、在线钱包本身可能带有coin mixing功能、交易所天然有coin mixing功能（如果交易所不暴露提币存币的记录）

## 补-零知识证明

证明者向验证者证明一个陈述是正确的，而无需透露该陈述是正确的外任何信息

数学基础：同态隐藏

- 如果$x,y$不同，那么$E(x)$和$E(y)$也不同
- 给定$E(x)$，很难反对出$x$的值（类似hiding）
- 同态运算：同态加法、同态乘法、扩展到多项式

为匿名性设计的加密货币：零币和零钞

## BTC-引起的思考

- hash pointer只有本地的地址，发布到区块链网络上会咋样？

  网络上没有指针，只有hash，全节点维护一个数据库保存`(key, value)`，常用的是levelDB

- 分布式共识

  BTC实际上也没有取得 真正的共识，但是实际和理论是不一样的
